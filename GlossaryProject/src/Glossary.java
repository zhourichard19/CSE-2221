import java.util.Comparator;

import components.map.Map;
import components.map.Map1L;
import components.queue.Queue;
import components.queue.Queue1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * A glossary webpage program from a txt file
 *
 * @author Richard Zhou
 */
public final class Glossary {

    /**
     * Default constructor--private to prevent instantiation.
     */
    private Glossary() {
        // no code needed here
    }

    private static class Sort implements Comparator<String> {
        @Override
        public int compare(String o1, String o2) {
            return o1.compareTo(o2);
        }
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>Sample Glossary</title> </head> <body>
     * <h2>Sample Glossary</h2>
     * <hr />
     * <h3>Index</h3>
     * <ul>
     *
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputIndexHeader(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";
        out.println("<html>");
        out.println("<head>");
        out.println("<title>Glossary</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("   <h2>Glossary</h2>");
        out.println("   <hr/>");
        out.println("   <h3>Index</h3>");
        out.println("<ul>");

    }

    /**
     * Outputs the "closing" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * </ul>
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     *
     */
    private static void outputIndexFooter(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        out.println("  </ul>");
        out.println("</body>");
        out.println("</html>");
    }

    /*
     * Gets the terms and definitions from the text and puts them into a Queue
     *
     * @param wordMap a map of every word in the txt with the word followed by
     * the definition
     *
     * @param in the reader that will read the files of the txt
     *
     * @return a queue containing all of the words and definitions
     *
     * @requires in to be open, and wordMap to be empty so that terms can be
     * added to the word Map
     *
     * @ensures Map has the words and definitions added to the map. Queue is
     * also updated to be a list of all of the terms in the txt.
     */

    private static Queue<String> getDef(Map<String, String> wordMap,
            SimpleReader in) {
        //creates the queue that is needed to be returned for the list of terms
        Queue<String> termQueue = new Queue1L<>();
        //runs through every term in the txt file until there are no more terms
        //left, adding the terms to the respective map and queue
        while (!in.atEOS()) {
            //creates the string for the word
            String word = in.nextLine();
            //creates the string for the definition
            String def = in.nextLine();
            //creates a temporary variable to keep track of the words being
            //updated in the for loop
            String temp = " ";
            //goes through every word and also making sure that the word
            //has a character inside of it.
            while (!in.atEOS() && temp.length() > 0) {
                //updates temp every time knowing temp is a limiting variable
                temp = in.nextLine();
                //checks to make sure that temp has more than one character;
                if (temp.length() > 0) {
                    def += temp;
                }
            }
            //adds the saved words into the map and the queue;
            wordMap.add(word, def);
            termQueue.enqueue(word);
        }
        return termQueue;
    }

    /**
     * Reads the map and produces links for each term. The links contain the
     * term on the top followed by its definition Link are in the same folder as
     * index
     *
     * @param out
     *            the folder that the user saved to
     * @param wordMap
     *            map of the words and definitions
     * @param termQueue
     *            a queue with all of the words in the txt
     * @requires termQueue and wordMaps not to be empty
     * @ensures neither wordMap or termQueue will be modified
     */
    private static void getUrls(Map<String, String> wordMap,
            Queue<String> termQueue, String out) {

        //creates a temporary variable to be updated and then saved by the other
        //queue
        Queue<String> temp = new Queue1L<>();

        //checks every word and definition in the queue to create a link
        while (termQueue.length() > 0) {
            //takes the first term in the queue and removes it, saving it into
            //word
            String word = termQueue.dequeue();
            //gets the definition of the word from the map by saving it into def
            String def = wordMap.value(word);
            //saves the word in the temperary wueue to be updated
            temp.enqueue(word);

            //creates the url for the specific word and saves it to link
            //link is the simple writer for every term that goes through and
            //prints the html out
            SimpleWriter link = new SimpleWriter1L("lib/" + word + ".html");

            //generates the html for printing the page for the definition of the
            //word and the definition
            link.println("<html>");
            link.println("<head>");
            link.println("<title>" + word + "</title>");
            link.println("</head>");
            link.println("<body>");
            //prints the red font for word and the word itself
            link.println("<h2><b><i><font color=\"red\">" + word
                    + "</font></i></b></h2>");
            //prints out the definition under the word
            link.println("<blockquote>" + def + "</blockquote>");
            link.println("<hr />");
            //the return statement in order to get back to the glossary
            //index page
            link.println("<p>Return to <a href=\"index.html\">index</a>.</p>");
            link.println("</body>");
            link.println("</html>");

            //closes the simplewriter;
            link.close();
        }
        //updates the words in the temp variable and transfers them to queue
        termQueue.transferFrom(temp);
    }

    /**
     * Takes a string and looks for the first word starting at the position The
     * word is determined by if there is a separator (periods, spaces, commas,
     * etc). Once the method finds a separator, it determines the word is the
     * starting position until right before the separator The word is returned
     * If the position is at a separator, the separator alone is returned
     *
     * @param text
     *            String that is to have words examined
     * @param position
     *            Staring position to check for word
     * @param separators
     *            A set of designated separators
     * @return Word or separator if the position starts at one
     * @requires text is not empty separators is not empty position is less than
     *           the length of text
     */
    private static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        //creates a string that holds the word that is separated
        String nextWordOrSeparator = "";

        //the first character a the position position
        char b = text.charAt(position);
        //the boolean to ensure the program keeps looping is made and is
        //set by checking to see whether the character is a separator or not

        //ensures that the character is a separator before going into
        //the code
        if (separators.contains(b)) {
            //while statement that fills the string with the word after the
            //Separator
            while (separators.contains(b) && position < text.length()) {
                //gets the character at the next position
                b = text.charAt(position);
                //saves the character from that next position into a string for
                // a word
                nextWordOrSeparator += b;

                //moves on to the next position of the set
                position++;
            }
        } else {
            //checks to return the separating character because there is no
            //character in the set
            while (!separators.contains(b) && position < text.length()) {
                //gets the character at the position
                b = text.charAt(position);
                //adds that character to the string that will be returned
                nextWordOrSeparator += b;

                position++;

            }
        }
        return nextWordOrSeparator;
    }

    /*
     * Modifies the definition in the string (the value) so that if there are
     * any terms that are stored as the keys and also in termQueue within the
     * definition, they will be linked to corresponding definition page
     *
     * @param wordMap map of strings where <term,term's definition>
     *
     * @param termQueue a queue that contains all the terms
     *
     * @param out file where index and other files are being stored from user
     * input
     *
     * @requires wordMap and termQueue are not empty termQueue is the same as
     * the keys in wordMap
     *
     * @ensures wordMap and termQueue are not modified will link to files
     * created in getUrls
     */

    private static void definitionLink(Map<String, String> wordMap,
            Queue<String> termQueue, String out) {
        //creates a temporary queue to be edited and replaced when finished
        Queue<String> temp = new Queue1L<>();
        //creates set filled with separators which will be separating the
        //words in the other sets
        Set<Character> separators = new Set1L<>();

        //a list of separators that are added to a list of separators
        separators.add('.');
        separators.add(',');
        separators.add(' ');
        separators.add(':');
        separators.add('!');
        separators.add('?');

        //sets the position of the character we will be comparing
        int pos = 0;

        //checks to go through every character in the termQueue
        while (termQueue.length() > 0) {
            //gets the terms at the beginning of termQueue
            String term = termQueue.dequeue();
            //adds the term to the next queue variable which will be changed
            //and then updated
            temp.enqueue(term);

            //creates a another string to put the definition of the term into
            String definition = wordMap.value(term);
            //creates the final form of the definition with a url if changed
            String finalDefinition = " ";

            //checks to make sure that the position is within the string
            while (pos < definition.length()) {
                //get the next word if the next is a word or separator
                String word = nextWordOrSeparator(definition, pos, separators);
                //if the next string is a word, then checks to see if the
                //definition has the word from the txt within it
                if (wordMap.hasKey(word)) {
                    //if the definition has the defined word in the definition,
                    //then the word is updated with a link within the definition
                    finalDefinition += "<a href=\"" + word + ".html\">" + word
                            + "</a>";
                    //if its just a word that doesn't have a definition
                    //then the word is just updated
                } else {
                    finalDefinition += word;
                }
                //updates the position after the word or separator is found
                pos = pos + word.length();
            }
            //replaces the original definition with a new one with or without
            //a link
            wordMap.replaceValue(term, finalDefinition.substring(1));
            //resets position
            pos = 0;
        }
        //updates termQueue from the updated terms
        termQueue.transferFrom(temp);
    }

    /**
     * Given a file name from the user, output files are created in user given
     * folder. One of them is an index with each term from the input file. This
     * index links to their definitions, also given by the user
     *
     * @requires The input file must be formatted this way: term definition(can
     *           be multiple lines)
     *
     *           term definition
     *
     *           and so on
     *
     * @param args
     *            Command-line arguements: not used
     */
    public static void main(String[] args) {
        //creates the reader for asking which folder the user wants to save in
        SimpleReader userIn = new SimpleReader1L();
        //creates an output file to print out commands
        SimpleWriter userOut = new SimpleWriter1L();

        //prints out the command for which file to read
        userOut.print("Enter input file: ");
        //saves that file into the inout string
        String input = userIn.nextLine();

        //asks the user for a save destination
        userOut.print("Enter folder where output files will be saved: ");
        //saves that folder name into the string output
        String output = userIn.nextLine();

        //a new simple reader to read what is inside of the input file that
        //was previously asked for
        SimpleReader in = new SimpleReader1L(input);
        //a new simple writer to print what is inside of the input file that
        //was previously asked for
        SimpleWriter out = new SimpleWriter1L(output + "/index.html");

        //creates a new wordmap that is empty for the input files words to be
        //entered into in the method getDef
        Map<String, String> wordMap = new Map1L<>();
        //creates the queue for getting the list of terms
        Queue<String> termQueue = new Queue1L<>();

        //gets the list of terms and saves to termQueue. Also updates the
        //wordMap with words and definitions
        termQueue.append(getDef(wordMap, in));

        //creates a comparator in order to sort terms alphabetically
        Comparator<String> a = new Sort();
        //sorts the termQueue alphabetically
        termQueue.sort(a);

        //gets the links for the words that are within definitions
        definitionLink(wordMap, termQueue, output);
        //makes urls for the main word pages in the text file
        getUrls(wordMap, termQueue, output);
        //prints out the format of the html file
        outputIndexHeader(out);

        //prints out the terms from the txt file as long is there is another
        //term and gives the term a link
        while (termQueue.length() > 0) {
            String term = termQueue.dequeue();
            out.println(
                    "<li><a href=\"" + term + ".html\">" + term + "</a></li>");
        }
        // prints out the ending of the html so it closes all of the parts
        outputIndexFooter(out);

        //closes all of the Simple readers and Simple Writers
        userIn.close();
        userOut.close();
        out.close();

    }
}
